# 夏 – natsu – summer.

sum type generator for go 1.18+

## Usage

For a module with `natsu` in the `go.mod` file, a sum type can be generated by adding the following to a `.go` source file:

```
//go:generate go run github.com/butzopower/natsu <pkg> <union> <sumTypeToGenerate>
```

For example:

```go
package models

type Cat struct { NumLives int }
type Dog struct { Tricks []string }

//go:generate go run github.com/butzopower/natsu my/package/models P Pet
type P interface {
    Cat | Dog
}
```

Running `go generate` in this directory will generate a file `pet.go` that can be used like so:

```go
package main

import "my/packages/models"

func main() {
    petCat := models.PetOf(models.Cat{ NumLives: 9})
    petDog := models.PetOf(models.Dog{ Tricks: []string{"sit", "stay"}})
    
    exec := models.PetExecutor().
        WithCat(func(cat models.Cat) { println("the cat has " + cat.NumLives + " lives")}).
        WithDog(func(dog models.Dog) { 
            println("our dog knows the following tricks:")
            for _, trick := range dog.Tricks {
                println(" - " + trick)
            }
        })
    
    exec.Exec(petCat) // output: 
                      // the cat has 9 lives
    
    exec.Exec(petDog) // output: 
                      // our dog knows the following tricks:
                      //  - sit
                      //  - stay
}

```

## Why

What benefit does a sum type provide over a type switch?

Consider the below example of function constrained by a type union that uses a type switch:

```go
type Cat struct {
    Name string 
    SharpClaws bool
}

type Dog struct {
    Name string
    Trained bool
}

type Pet interface {
    Cat | Dog
}

func Cuddle[T Pet](pet T) {
    var switchablePet interface{} // ❌ required as can not switch on type constraint
    switchablePet = pet
    switch p := switchablePet.(type) {
    case Cat:
        if p.SharpClaws {
            print("ow, it scratched me")
        }
    case Dog:
        if !p.Trained {
            print("ah, it slobbered me")
        }
    case string: // ❌ allowed as can not check exhaustively
        print("uh wut")
    default:     // ❌ required as can not check exhaustively
        print("there is no pet?")
    }
}

func main() {
    Cuddle(Cat{Name: "Tex", SharpClaws: true})
    Cuddle(Dog{Name: "Fifi", Trained: false})
    
    // ✅ does not compile: string does not implement Pet 
    Cuddle("strings are what cats play with")
}

```

## Inspiring Projects

* [enumer](https://github.com/dmarkham/enumer)