package generator

import (
	"fmt"
	"github.com/butzopower/natsu/core"
	. "github.com/dave/jennifer/jen"
)

type containers map[string]core.TermPath

type sumTypeStruct struct {
	Id      string
	ValueId string
}

func Generate(sumTypeId string, union core.UnionDetails) *File {
	file := NewFilePath(union.Path)

	file.PackageComment("Code generated by github.com/butzopower/natsu, DO NOT EDIT.")
	containerInterface, containerInterfaceFn := generateContainerInterface(file, sumTypeId)
	containers := generateContainers(file, sumTypeId, union.Terms, containerInterfaceFn)
	sumType := generateStruct(file, sumTypeId, containerInterface)

	generateConstructor(file, union, containers, sumType)
	generateExecutor(file, containers, sumType)
	generateMapper(file, containers, sumType)

	return file
}

func generateContainerInterface(file *File, namespace string) (string, string) {
	interfaceId := fmt.Sprintf("container%s", namespace)
	interfaceFn := fmt.Sprintf("%sFn", interfaceId)

	file.Type().Id(interfaceId).Interface(
		Id(interfaceFn).Params(),
	)

	return interfaceId, interfaceFn
}

func generateContainers(
	file *File,
	namespace string,
	unionTerms []core.TermPath,
	interfaceFn string,
) containers {
	containersToReturn := make(containers)

	for _, term := range unionTerms {
		memberContainerId := fmt.Sprintf("container%s%s", namespace, term.Local)
		file.Type().Id(memberContainerId).Struct(
			Id("v").Add(qualifiedTerm(term)),
		)

		file.Func().Params(Id("c").Id(memberContainerId)).Id(interfaceFn).Params().Block()

		containersToReturn[memberContainerId] = term
	}

	return containersToReturn
}

func generateConstructor(
	file *File,
	union core.UnionDetails,
	c containers,
	sumType sumTypeStruct,
) {
	typeId := "T"
	constructorId := fmt.Sprintf("%sOf", sumType.Id)
	paramName := "input"
	switchOn := "switchOn"
	valueName := "value"

	file.Line()
	file.Comment("Of")

	file.Func().Id(constructorId).
		Types(Id(typeId).Qual(union.Union.Package, union.Union.Local)).
		Params(Id(paramName).Id(typeId)).
		Id(sumType.Id).
		Block(
			Var().Id(switchOn).Interface(),
			Id(switchOn).Op("=").Id(paramName),
			Switch(Id(valueName).Op(":=").Id(switchOn).Dot("").Parens(Type())).Block(constructorSwitchOptions(c, valueName, constructorId, sumType)...),
		)
}

func constructorSwitchOptions(
	c containers,
	valueName string,
	constructorName string,
	sumType sumTypeStruct,
) []Code {
	var options []Code

	for containerId, term := range c {
		var caseStatement = Case(qualifiedTerm(term)).Block(
			Return(Id(sumType.Id).Values(Id(containerId).Values(Id(valueName)))),
		)

		options = append(options, caseStatement)
	}

	options = append(
		options,
		Default().Block(Panic(Lit("called "+constructorName+" with invalid option"))),
	)

	return options
}

func generateStruct(
	file *File,
	sumTypeId string,
	containerInterfaceId string,
) sumTypeStruct {
	structName := sumTypeId
	valuePropertyName := "v"

	file.Type().Id(structName).Struct(
		Id("v").Id(containerInterfaceId),
	)

	return sumTypeStruct{
		Id:      structName,
		ValueId: valuePropertyName,
	}
}
