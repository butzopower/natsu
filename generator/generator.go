package generator

import (
	"fmt"
	. "github.com/dave/jennifer/jen"
	"natsu/core"
)

type containers map[string]core.TermPath

type sumTypeStruct struct {
	Id      string
	ValueId string
}

func Generate(r core.Result) *File {
	file := NewFilePath(r.Path)

	file.PackageComment("Code generated by github.com/butzopower/natsu, DO NOT EDIT.")
	containerInterface, containerInterfaceFn := generateContainerInterface(file, r)
	containers := generateContainers(file, r, containerInterfaceFn)
	sumType := generateStruct(file, r, containerInterface)
	generateConstructor(file, r, containers, sumType)
	generateExecutor(file, r, containers, sumType)

	return file
}

func generateContainerInterface(file *File, r core.Result) (string, string) {
	interfaceId := fmt.Sprintf("container%s", r.Union.Local)
	interfaceFn := fmt.Sprintf("%sFn", interfaceId)

	file.Type().Id(interfaceId).Interface(
		Id(interfaceFn).Params(),
	)

	return interfaceId, interfaceFn
}

func generateContainers(file *File, r core.Result, interfaceFn string) containers {
	containersToReturn := make(containers)

	for _, term := range r.Terms {
		memberContainerId := fmt.Sprintf("container%s", term.Local)
		file.Type().Id(memberContainerId).Struct(
			Id("v").Qual(term.Package, term.Local),
		)

		file.Func().Params(Id("c").Id(memberContainerId)).Id(interfaceFn).Params().Block()

		containersToReturn[memberContainerId] = term
	}

	return containersToReturn
}

func generateConstructor(
	file *File,
	r core.Result,
	c containers,
	sumType sumTypeStruct,
) {
	typeId := "T"
	constructorId := fmt.Sprintf("%sOf", r.Union.Local)
	paramName := "input"
	switchOn := "switchOn"
	valueName := "value"

	file.Func().Id(constructorId).
		Types(Id(typeId).Qual(r.Union.Package, r.Union.Local)).
		Params(Id(paramName).Id(typeId)).
		Id(sumType.Id).
		Block(
			Var().Id(switchOn).Interface(),
			Id(switchOn).Op("=").Id(paramName),
			Switch(Id(valueName).Op(":=").Id(switchOn).Dot("").Parens(Type())).Block(constructorSwitchOptions(c, valueName, constructorId, sumType)...),
		)
}

func constructorSwitchOptions(
	c containers,
	valueName string,
	constructorName string,
	sumType sumTypeStruct,
) []Code {
	var options []Code

	for containerId, term := range c {
		var caseStatement = Case(Qual(term.Package, term.Local)).Block(
			Return(Id(sumType.Id).Values(Id(containerId).Values(Id(valueName)))),
		)

		options = append(options, caseStatement)
	}

	options = append(
		options,
		Default().Block(Panic(Lit("called "+constructorName+" with invalid option"))),
	)

	return options
}

func generateStruct(file *File, r core.Result, containerInterfaceId string) sumTypeStruct {
	structName := fmt.Sprintf("Tagged%s", r.Union.Local)
	valuePropertyName := "v"

	file.Type().Id(structName).Struct(
		Id("v").Id(containerInterfaceId),
	)

	return sumTypeStruct{
		Id:      structName,
		ValueId: valuePropertyName,
	}
}
